'use strict';(function(){const indexCfg={cache:true};indexCfg.doc={id:'id',field:['title','content'],store:['title','href','section'],};const index=FlexSearch.create('balance',indexCfg);window.bookSearchIndex=index;index.add({'id':0,'href':'/docs/tools/BEC/','title':"B E C",'section':"Tools",'content':"フロー furoBEC #  The furo build essentials container. #  This container contains all tools you need to work with a furo spec project.\nUsage #  Bash mode\ndocker run -it --rm -v `pwd`:/specs thenorstroem/furo-bec # do your stuff # type exit to quit exit  Command mode\ndocker run -it --rm -v `pwd`:/specs thenorstroem/furo-bec build   TIPP: If your spectools commands have to access different directories, do not forget to mount them.\n Installed Tools #   golang git protoc protoc-gen-grpc-gateway (v2) protoc-gen-openapiv2 protoc-gen-go protoc-gen-go-grpc simple-generator spectools furoc   No furoc generators are installed. Add the needed furoc-gen-XXX to the .furobecrc file.\n "});index.add({'id':1,'href':'/docs/overview/','title':"Overview",'section':"Docs",'content':"Overview #  This guide describes how to use the specs, including *.service.spec, *.type.spec file syntax.\nWe will use µSpec notation when it makes no difference or it is easier to use.\nThe standard notation is then used when the µSpec notation does not cover the feature.\nFor a better understanding and when possible the µSpec, spec and the resulting proto will be shown.\n This is a reference guide – for a step by step example, see the tutorials or sample projects.\nThe pages Defining a type , Defining a service and Style Guide should give you enough information for a brief overview. Most of the other pages are detailed topics and can be read later or by interest or need.\nFor the tooling, the minimum you need is spectools. If your .spectools config have specified additional commands and flows, make sure you install the corresponding dependencies too.\nWhat\u0026rsquo;s Generated From Your specs? #  protos #  First of all, protos and therfore all you can generate with protos.\nThis is done by spectools with the following commands.\n spectools genMessageProtos - Generate the message protos from the type specs. spectools genServiceProtos - Generate service protos from the specs  client environment (es6) #  The client types as es6 module which can be consumed by @furo/furo-data* and various web components of furo. This module allows the usage of the same types on the backend side and in the browser.\n spectools genEsModule - generate es6 spec module  Validators, DB Shemas, Custom Documentation,\u0026hellip; #  With furoc, which has a lot of similarities with protoc, you can easyli write your custom generators. The main benefit is that you have a much higher information density then you have with the protos alone (to be fair, you can have the same information density with protos too, but this is not so trivial). The input format for a furoc generator is a yaml structure with your services and types. The output format is the same like in protoc.\nUser Interface Components #  Yes, you have read it correctly. You can generate web-components that you can use in your web projects. At the moment you can do that with @furo/ui-builder. A furoc based version is in development and comming soon.\nREST APIs indirect #  This is done by using the protos with protoc-gen-grpc-gateway.\nprotoc -I . --grpc-gateway_out ./gen/go \\  --grpc-gateway_opt logtostderr=true \\  --grpc-gateway_opt paths=source_relative \\  --grpc-gateway_opt grpc_api_configuration=path/to/config.yaml \\  your/service/v1/your_service.proto Open Api Specifications indirect #   Open Api aka swagger can be used for various things.\nGenerating Open Api Specifications is done by using the generated protos with protoc-gen-openapiv2.\nprotoc -I . --openapiv2_out ./gen/openapiv2 --openapiv2_opt logtostderr=true your/service/v1/your_service.proto Various Clients and Servers indirect #  By using the swagger files on https://editor.swagger.io/ you can generate server and client code for different languages and architectures. You do not have to write the backend as grpc service to work with the furo client framework.\nImporting proto Messages #  You can import your existing proto messages with the protoc-gen-furo-specs protoc plugin. After running the spectools, you should receive the same proto file (proto3).\nfuroc #   Furoc is the compiler/transpiler for the specs.\nFuroc will pass a yaml structure with the current config of the spec project, the types, the services, the installed types (dependencies) and the installed services (dependencies) to the generators.\nRelated Documents #    Anatomy of a µType spec  Anatomy of a µService spec  Anatomy of a type spec  Anatomy of a service spec  Good to Read #  [API Design Guide from google #  The API Design Guide from google gives you a good guideline for designing your APIs.\nProtocol Buffers #  This page gives you a good overview on Protocol Buffers.\ngRPC #  This site grpc.io gives you a good entry point to grpc itself.\n"});index.add({'id':2,'href':'/docs/overview/define_type/','title':"Defining a Type",'section':"Overview",'content':"Defining A Type #  Furo types are organized in packages, you can have as many types per package as you want.\nLets do a simple example in µSpec and spec and see what the resulting proto will be.\nDefine the type in µSpec #  The following example is a complete type definition. You can use every type from your specs and installed dependencies. You do not need to import them. The imports are resolved and checked by the spectools when you translate your µSecs to standard specs with the command spectools muSpec2spec.\nFile: muspec/auth/auth.types.yaml\n- type:\u0026#39;auth.Credentials #Credentials type for login.\u0026#39;fields:password:\u0026#39;* string:1 #The password.\u0026#39;username:\u0026#39;* string:2 #The username or email, or something to identify.\u0026#39;second_factor:\u0026#39;string:3 #A second factor like TOTP.\u0026#39;It helps a lot to know the anatomy of a µSpec, read more here\nDefine the type in standard spec #  The standard specs have a much higher information density then the µSpecs. The spectools will fill out as much as possible with good defaults by using the .spectools configuration file.\nIt helps a lot to know the anatomy of a standard spec, read more here\nFile: specs/auth/Credentials.type.spec\nname:Credentialstype:Credentialsdescription:Credentials type for login.__proto:package:authtargetfile:auth.protoimports:[]options:go_package:github.com/foo/bar/dist/pb/auth;authpbjava_multiple_files:\u0026#34;true\u0026#34;java_outer_classname:AuthProtojava_package:com.authfields:password:type:stringdescription:The password.__proto:number:1oneof:\u0026#34;\u0026#34;__ui:component:\u0026#34;\u0026#34;flags:[]noinit:falsenoskip:falsemeta:default:\u0026#34;\u0026#34;hint:\u0026#34;\u0026#34;label:auth.Credentials.password.labeloptions:flags:[]list:[]readonly:falserepeated:falsetypespecific:nullconstraints:required:is:\u0026#34;true\u0026#34;message:password is requiredusername:type:stringdescription:The username or email, or something to identify.__proto:number:2oneof:\u0026#34;\u0026#34;__ui:component:\u0026#34;\u0026#34;flags:[]noinit:falsenoskip:falsemeta:default:\u0026#34;\u0026#34;hint:\u0026#34;\u0026#34;label:label.Credentials.usernameoptions:flags:[]list:[]readonly:falserepeated:falsetypespecific:nullconstraints:required:is:\u0026#34;true\u0026#34;message:username is requiredsecond_factor:type:stringdescription:A second factor like TOTP.__proto:number:3oneof:\u0026#34;\u0026#34;__ui:component:\u0026#34;\u0026#34;flags:[]noinit:falsenoskip:falsemeta:default:\u0026#34;\u0026#34;hint:\u0026#34;\u0026#34;label:label.auth.Credentials.second_factoroptions:nullreadonly:falserepeated:falsetypespecific:nullconstraints:{}Resulting proto from the type definition #  // Code generated by furo-proto-gen. DO NOT EDIT. syntax = \u0026#34;proto3\u0026#34;;package auth;option go_package = \u0026#34;github.com/foo/bar/dist/pb/auth;authpb\u0026#34;;option java_multiple_files = true;option java_outer_classname = \u0026#34;AuthProto\u0026#34;;option java_package = \u0026#34;com.auth\u0026#34;;// Credentials type for login. message Credentials { // The password.  string password = 1; // The username or email, or something to identify.  string username = 2; // A second factor like TOTP.  string second_factor = 3;}Specifying Field Types #  Use the scalar value types from proto3 or types that you have defined or installed.\nYou have always to write the package name (package.Type) too , when you plan to use the furo client framework, even when you are on the same file.  Packages and Name Resolution #   Like in protobuf the type name resolution works like C++: first the innermost scope is searched, then the next-innermost, and so on, with each package considered to be \u0026ldquo;inner\u0026rdquo; to its parent package. A leading \u0026lsquo;.\u0026rsquo; (for example, .foo.bar.Baz) means to start from the outermost scope instead.\nField IDs #  The field IDs are also used for the generated protos as field numbers.\nReserved Fields #  There is no concept for reserved fields at the moment.\n"});index.add({'id':3,'href':'/docs/specs/types/','title':"Types",'section':"Specs",'content':"Anatomy of a type spec #  A type spec consists of 2 main sections (fields and __proto) and some properties on the root.\nname #  This property is deprecated. Fill in the same as you fill in on the property type for compatibility with some old generators.\ntype #  The type of the field without the package name. Write it in CamelCase with a capital letter at the beginning.\n__proto #  The proto section defines some properties to generate the proto files.\n__proto:package:authtargetfile:auth.protoimports:[]options:go_package:github.com/veith/doit-specs/dist/pb/auth;authpbjava_multiple_files:\u0026#34;true\u0026#34;java_outer_classname:AuthProtojava_package:com.furo.baseauthField package string #  This is the desired proto package name.\nIn proto this is optional, in specs this field is not optional\n You can add an optional package specifier to a .proto file to prevent name clashes between protocol message types.\n  Learn more about packages in protobuf\nField targetfile string #  The name of the proto file. Multiple types can write to the same file, if they belong to the same package. The file will be generated in a folder according to the package.\nA package company.groups with a protofile green.proto and a config target dist/proto will be generated to\ndist/proto/company/groups/green.proto\nField imports []string #  Add imports by hand only if you do not work with the spectools chain. Spectools will check and fix imports for you.\nThis can be done with the command spectools checkImports. Imports that can not be found would be reported.\nImports that are not needed anymore, are removed too.\nimports:- google/type/date.proto- google/type/timeofday.protofield options map\u0026lt;string, string\u0026gt; #  When needed, you can add options for your protos. This can be something like the following:\noptions:go_package:github.com/veith/doit-specs/dist/pb/auth;authpbjava_multiple_files:\u0026#34;true\u0026#34;java_outer_classname:AuthProtojava_package:com.furo.baseauthPotential pitfall: The value of an option is a string, so write values which should have true as value like this:\njava_multiple_files: \u0026quot;true\u0026quot;\nWhen you write true not as string, the value will not work.\n Fields map\u0026lt;string, Field\u0026gt; #  The most important part of a type spec are the fields. The fields section contains a map with fields. A field itself has the properties type, description, meta, constraints, __ui and __proto.\npassword:type:stringdescription:The password.__proto:number:1oneof:\u0026#34;\u0026#34;__ui:nullmeta:default:\u0026#34;\u0026#34;hint:\u0026#34;\u0026#34;label:auth.Credentials.password.labeloptions:flags:[]list:[]readonly:falserepeated:falsetypespecific:nullconstraints:required:is:\u0026#34;true\u0026#34;message:password is requiredField type string #  The type of the field. This should be one of the types that you have defined or installed.\nField description string #  It is a good practice to give a good description of the type. This description will go to the generated protos and other generates.\nField meta Meta #  In the meta field you can set additional information for field in your type. Only the field meta.repeated does impact the proto. The options that you set here are thought for the backend and the client. This properties are domain specific and can give instructions for generators, validators or displaying the field.\nmeta:default:\u0026#34;1234\u0026#34;hint:\u0026#34;look at the post-it on your monitor or below the keyboard\u0026#34;label:auth.Credentials.password.labeloptions:flags:[]list:[]readonly:falserepeated:falsetypespecific:nulldefault string #  The default value for the field when you create a new object. Keep in mind that this is a string and should be parsed by your implementation.\nhint string #  This property gives you a hint message. On the furo client libs, this property goes through the translation engine first [optional]. The furo-data-xxx-input components will display this value below the field, when you focus it.\nlabel string #  This property labels the field. On the furo client libs, this property goes through the translation engine first [optional]. The furo-data-xxx-input components will display this value as placeholder (as long the field is empty) and or label (as soon you have some value)\noptions.flags []string #  options.list []Anything #  readonly bool #  Define the field as readonly. The furo client libs will not send this field on a request by default.\nrepeated bool #  Define the field as repeated. Keep in mind that not all combinations are possible. As an exapmle, if you set oneof in __proto, repeated must be set to false.\ntypespecific: Anything #  Deprecated\nThis is something like a extension point for fields in types. Use the extensionpoint on the field please.\nField constraints map\u0026lt;string, Constraint\u0026gt; #  Static constraints are defined on a per field basis. The client libs would use this information to mark the fields in a form which are not valid. This does not mean that you should not check the data on the server side.\nSide note:\nThe constraint may be overwritten by a server response (with meta.fieldname.constraints:{...}).\n constraints:required:#\u0026lt;-- constraintis:\u0026#34;true\u0026#34;#\u0026lt;-- value as stringmessage:password is required #\u0026lt;-- message to write on constraint violationmax:is:\u0026#34;100\u0026#34;message:not more then 100min:is:\u0026#34;10\u0026#34;message:at least 10step:is:\u0026#34;5\u0026#34;message:incrase by 5 onlyYou have to parse the is field according to your type when you want to use the spec directly. The client libs sets the constraints to the according input fields where they are expected as string. So nothing is to do there. If you write extended validators for the client, you have to parse the is value too.\nField __proto: Fieldproto #  Define the field id (proto number) and set a oneof group if needed.\n The oneof property in detail\n__proto:number:1oneof:\u0026#34;\u0026#34;Field __ui: Uiprops #  In this property you will define ui relevant attributes of a field. This information is used by some generators. The idea behind is that you can give hints for your generators.\nThe generator @furo/ui-builder use the component property to generate the input for the field with an explicit component, if this property is not set, it will look for the best matching input component. For a string i.e. a text input will be selected. In the example below we know that we have bigger texts and request a textarea to be used.\n__ui:{component:furo-data-textarea-inputflags:- fullno_init:falseIt depends on your generator what you have to fill in the properties. When your generator requires concrete component names, then you have to write it so. When your generator can handle your \u0026ldquo;intention\u0026rdquo; then a flag big or lot would be all you have to set.\nThe property no_init tells the generator to not build something for this input.\nRecomendation:\nWhen this information is enough for your generators, use it. If you need more flexibility, write your own field-extension.\n "});index.add({'id':4,'href':'/docs/%C2%B5Specs/types/','title':"Types",'section':"µSpecs",'content':"Anatomy of a type µSpec #  The µType specs are regular yaml files.\nThe \u0026ldquo;type-object\u0026rdquo; contains 3 fields. The fields type, fields are mandatory, the field target is optional and autogenerated when ommited.\nYou can have as many type definitions per file as you want. It makes sense that you put types in a file, that belongs togehter.\nFile: muspec/sample.types.yaml\n- type:\u0026#39;sample.Sample #A sample type\u0026#39;fields:password:\u0026#39;* string:1 #The password.\u0026#39;username:\u0026#39;* string:2 #The username or email, or something to identify.\u0026#39;details:\u0026#39;sample.Details:3 #Details.\u0026#39;target:sample.proto # this is \u0026#34;optional\u0026#34;, if you omit this, the spectools will use the package name (auth)- type:\u0026#39;sample.Details #A sample type\u0026#39;fields:birth_date:\u0026#39;* google.type.Date:1 #The birth date.\u0026#39;weight:\u0026#39;* number:2 #The weight.\u0026#39;age:\u0026#39;- number:3 #Calculated field for displaying the age, because the calculations are very hard.\u0026#39;target:sample.proto The type line #  - type:\u0026#39;sample.Sample (ce) #A sample type\u0026#39;!___! !___________! !__! !____________!| | | || type name | || | || | description (recomended) begins with a #| || indicator to create a collection and or a entity for the type (optional)| | field name type name #  is defined by package.Type\nAuto entity and collection generator #  (ce) write a c to autogenerate the collection type and/or e to generate the entity type for this type.\nThe spectools can generate specs for entities and collections. Entities and collections are usualy used in services as a response. If the generated specs are not suitable enough for you, you always have the possibility to write response by yourself.\nThe generated specs are optimized for the usage with the furo client framework. Atain, you do not have to use the furo client framework to work with furo fidls.\ndescription #  It is a good practice to give a good description of the type. This description will go to the generated protos and other generates.\nFields #  In the \u0026ldquo;fields-object\u0026rdquo;, what a surprise, you define the fields / attributes of a type.\nfieldname:\u0026#39;* string:2 #The description.\u0026#39;!_______! !_!!____!!_!!________________!| | | | | | | | | description (recomended) begins with a #field name | | | | | field id, indicated by a :| | | type | Indicator for required (*), readonly (-), repeated ([])fieldname #  The name of the field\nindicator required #  If the field is required, type in a *\nindicator readonly #  If the field is readonly, type in a -\nindicator repeated #  If the field is repeated, type in a []\ntype #  Types are the same like in protobuf\nfield id #  The field id must be unique, the generated protos use them too\ndescription #  It is a good practice to give a good description of the type. This description will go to the generated protos and other generates.\n"});index.add({'id':5,'href':'/docs/%C2%B5Specs/','title':"µSpecs",'section':"Docs",'content':"µSpecs #  µSpecs or muSpecs are the short notation format of furo FIDL. If you are just interested in protobuf as output, you can get very far with this format. If you need enums you have add them in the standard spec, but are still able to work with the µSpec for the rest.\nOur main goal is to keep the µSpecs as small/simple as possible.\nThe µSpecs specification was built to make rapid progress in the design of prototypes. However, it has now been shown that they can cover a very wide range of use cases.\n"});index.add({'id':6,'href':'/docs/overview/define_service/','title':"Defining a Service",'section':"Overview",'content':"Defining A Service #  Furo services are organized in packages. They can use all types that you have defined in your project or are installed as dependencies.\nLets do a simple example in µSpec and spec and see what the resulting proto will be.\nDefine the service in µSpec #  The following example is a complete service definition. You can use every type from your specs and installed dependencies. You do not need to import them. The imports are resolved and checked by the spectools when you translate your µSecs to standard specs with the command spectools muSpec2spec.\nFile: muspec/auth/auth.services.yaml\n- name:AuthSessiondescription:Login with credentials. The service should set a auth cookie on successful login and delete it on logoutpackage:authtarget:authservice.protoservices:- md: \u0026#39;Create:POST /auth auth.Credentials , google.protobuf.Empty #Login with credentials #A login is nothing else then creating a valid session\u0026#39;- md: \u0026#39;Delete:DELETE /auth google.protobuf.Empty , google.protobuf.Empty #Logout.\u0026#39;It helps a lot to know the anatomy of a µService, read more here\nDefine the service in standard spec #  The standard specs have a much higher information density then the µSpecs. The spectools will fill out as much as possible with good defaults by using the .spectools configuration file.\nIt helps a lot to know the anatomy of a standard spec, read more here\nWhen you generate the specs from µSpecs, the spectools will generate all required types for the request and response in the same package that you have defined for your service. Spectools will try to use the best defaults for the types. You can always edit this pre generated types.\nFile: specs/auth/AuthSession.service.spec\nname:AuthSessionversion:\u0026#34;\u0026#34;description:Login with credentials. The service should set a auth cookie on successful login and delete it on logoutlifecycle:null__proto:package:authtargetfile:authservice.protoimports:- google/api/annotations.proto- auth/reqmsgs.proto- auth/auth.proto- google/protobuf/empty.protooptions:go_package:github.com/veith/doit-specs/dist/pb/auth;authpbjava_multiple_files:\u0026#34;true\u0026#34;java_outer_classname:AuthserviceProtojava_package:com.furo.baseauthservices:Create:description:\u0026#39;Login with credentials #A login is nothing else then creating a valid session\u0026#39;data:request:auth.Credentialsresponse:google.protobuf.Emptybodyfield:bodydeeplink:description: \u0026#39;Create:POST /auth auth.Credentials , google.protobuf.Empty #Login with credentials #A login is nothing else then creating a valid session\u0026#39;href:/authmethod:POSTrel:createquery:{}rpc_name:CreateAuthSessionDelete:description:Logout.data:request:google.protobuf.Emptyresponse:google.protobuf.Emptybodyfield:bodydeeplink:description: \u0026#39;Delete:DELETE /auth google.protobuf.Empty , google.protobuf.Empty #Logout.\u0026#39;href:/authmethod:DELETErel:deletequery:{}rpc_name:DeleteAuthSessionResulting proto from the service definition #  The service itself #  file: dist/protos/auth/authservice.proto\n// Code generated by furo spectools. DO NOT EDIT. syntax = \u0026#34;proto3\u0026#34;;package auth;option go_package = \u0026#34;github.com/veith/doit-specs/dist/pb/auth;authpb\u0026#34;;option java_multiple_files = true;option java_outer_classname = \u0026#34;AuthserviceProto\u0026#34;;option java_package = \u0026#34;com.furo.baseauth\u0026#34;;import \u0026#34;auth/auth.proto\u0026#34;;import \u0026#34;auth/reqmsgs.proto\u0026#34;;import \u0026#34;google/api/annotations.proto\u0026#34;;import \u0026#34;google/protobuf/empty.proto\u0026#34;;// Login with credentials. The service should set a auth cookie on successful login and delete it on logout service AuthSession { // Login with credentials #A login is nothing else then creating a valid session  rpc CreateAuthSession (CreateAuthSessionRequest) returns (google.protobuf.Empty){ //Create: POST /auth auth.Credentials , google.protobuf.Empty #Login with credentials #A login is nothing else then creating a valid session  option (google.api.http) = {\tpost: \u0026#34;/auth\u0026#34;\tbody: \u0026#34;body\u0026#34;\t}; } // Logout.  rpc DeleteAuthSession (DeleteAuthSessionRequest) returns (google.protobuf.Empty){ //Delete: DELETE /auth google.protobuf.Empty , google.protobuf.Empty #Logout.  option (google.api.http) = {\tdelete: \u0026#34;/auth\u0026#34;\t\t}; }}The request messages #  file: dist/protos/auth/reqmsgs.proto\n// Code generated by furo-proto-gen. DO NOT EDIT. syntax = \u0026#34;proto3\u0026#34;;package auth;option go_package = \u0026#34;github.com/veith/doit-specs/dist/pb/auth;authpb\u0026#34;;option java_multiple_files = true;option java_outer_classname = \u0026#34;ReqmsgsProto\u0026#34;;option java_package = \u0026#34;com.furo.baseauth\u0026#34;;import \u0026#34;auth/auth.proto\u0026#34;;import \u0026#34;google/protobuf/empty.proto\u0026#34;;// request message for CreateAuthService message CreateAuthServiceRequest {  // Body with auth.Credentials  .auth.Credentials body = 1;}// request message for CreateAuthSession message CreateAuthSessionRequest {  // Body with auth.Credentials  .auth.Credentials body = 1;}// request message for CreateSessionAuthService message CreateSessionAuthServiceRequest {  // Body with auth.Credentials  .auth.Credentials body = 1;}// request message for DeleteAuthService message DeleteAuthServiceRequest {  // Body with google.protobuf.Empty  .google.protobuf.Empty body = 1;}// request message for DeleteAuthSession message DeleteAuthSessionRequest {  // Body with google.protobuf.Empty  .google.protobuf.Empty body = 1;}// request message for DeleteSessionAuthService message DeleteSessionAuthServiceRequest {  // Body with google.protobuf.Empty  .google.protobuf.Empty body = 1;}"});index.add({'id':7,'href':'/docs/specs/','title':"Specs",'section':"Docs",'content':"Specs #  The specs or \u0026ldquo;standard specs\u0026rdquo; are the extended notation format of furo FIDL. If you are just interested in protobuf as output, consider to work with µSpecs.\nThe specs have extensionpoints on many places. If you need to add your extension, you have to add them at the extension points now. In older versions of the specs this was experimental, now they are an integral part of the specs.\nThe extensionpoint are ,in simple words, just a map\u0026lt;string,google.protobuf.Any\u0026gt;. Furoc gives you nice helpers to get your extensions in your generators. If you work with js based generators, the only thing that changes is the name.\nTypes #  A type spec in FIDL is compareable to a message in proto and have a lot of similarities.\nWhen you look at a field definition i.e. the only new field to the specs was oneof. The number field was added, because just using the index+1 was not enough.\nThere is a __proto option for the type itself, which defines the\n package targetfile imports options  Services #  A service spec in FIDL is compareable to a proto service definition with option (google.api.http) on every rpc. There is only a __proto extension for the service itself, which defines the\n package targetfile imports options  "});index.add({'id':8,'href':'/docs/tools/','title':"Tools",'section':"Docs",'content':"Useful tools to work with the furo FIDLs #  There are a lot of tools, you have at your hand at your fingertips. If you do not want to install them (a lot of work), you can simply use the docker image thenorstroem/furo-bec. It contains erery tool you need.\nspectools #  The spectools is the essential tool to work with furoc-FIDLs, it replaces the @furo/spec npm package.\nInstallation #  brew tap theNorstroem/tap brew install spectools @furo/ui-builder #  The @furo/ui-builder is the tool to build web-components from your specs. In the near future it will be replaced with furoc-gen-u33e.\nprotoc #  The protocol buffer compiler, protoc, is used to compile .proto files, which contain service and message definitions.\nprotoc-gen-furo-specs #  Protoc plugin to generate furo specs from proto file.\nprotoc-gen-grpc-gateway (v2) #  gRPC-Gateway is a plugin of protoc. It reads a gRPC service definition, and generates a reverse-proxy server which translates a RESTful JSON API into gRPC. This server is generated according to custom options in your gRPC definition.\nprotoc-gen-go #  Generate the go stubs.\nprotoc-gen-go-grpc #  This tool generates Go language bindings of services in protobuf definition files for gRPC.\nsimple-generator #  Very simple golang template engine for cli usage, using the golang template package and the template functions from sprig.\nfuroc #  The furoc \u0026ldquo;compiler\u0026rdquo; is a generator tool similar to protoc. There are no official plugins available at the moment. But furoc-gen-u33e will come in near future.\nfuroc-gen-xxx #  Is a placeholder for all furoc plugins that will come.\n"});index.add({'id':9,'href':'/docs/overview/default_values/','title':"Default Values",'section':"Overview",'content':"Fields And Default Values #  The client lib will fill the \u0026ldquo;proto\u0026rdquo; default values for the fields when they are not transmited. This means i.e. numeric types will get a 0, strings a empty string. The default value that you can specify in the specs has nothing to do with proto directly. Proto 3 does not know anything about default values.\nThis comes very handy when you create an instance of a type on the client side and pass the data object to a form.\nStatic Default Values #  The standard spec let you define a default value. This values are entered as string and must be parsed by them who use them. The client framework, does the parsing transparently for you.\nfields:description:type:stringdescription:Describe the fruit__proto:number:3oneof:\u0026#34;\u0026#34;__ui:nullmeta:default:\u0026#34;This is the default\u0026#34;#\u0026lt;-- default values goes here!hint:\u0026#34;\u0026#34;label:fruit.Fruit.description.labeloptions:flags:[]list:[]readonly:falserepeated:falsetypespecific:nullconstraints:required:is:\u0026#34;true\u0026#34;message:description is requiredJson Object Example #  It is recomended to enter the default values as json string. The javascript clients will not parse them, when you use yaml notation.\nfields:fruit:type:fruit.Fruit meta:#the following default value is a string too, it just look like a json object.default:| {\u0026#34;key\u0026#34;:\u0026#34;value\u0026#34;} Runtime Default Values #  This topic belongs more to the client libs and is here only for completenes.\nYou can set default value for a type on the client side during runtime with a server response via the meta field.\n{ \u0026#34;data\u0026#34;: { \u0026#34;id\u0026#34;: \u0026#34;1\u0026#34;, \u0026#34;scalar_string\u0026#34;: \u0026#34;this is a scalar string\u0026#34; }, \u0026#34;links\u0026#34;: [], \u0026#34;meta\u0026#34;: { \u0026#34;fields\u0026#34;: { \u0026#34;data.scalar_string\u0026#34;: { \u0026#34;meta\u0026#34;: { \u0026#34;label\u0026#34;: \u0026#34;scalar_string string label setted via response meta\u0026#34;, \u0026#34;readonly\u0026#34;: false, \u0026#34;default\u0026#34;: \u0026#34;runtime default value\u0026#34; } } } } } There are more patterns to feed the clien with default values. It is also possible to build a custom method which creates a default object on the server side and feed this to the data object on the client side to create a new object. Hint: by doing this do not forget to set the HATEOAS link for the rel create.  "});index.add({'id':10,'href':'/docs/overview/scalar_value_types/','title':"Scalar Types",'section':"Overview",'content':"Scalar Value Types #  Furo specs knows the same scalar types which are defined in ProtocolBuffers.\n   type note golang java es6     string Please use UTF-8 *string String String   bytes  []byte ByteString String   bool  *bool boolean Boolean   float  *float32 float Number   double  *float64 double Number   int32  *int32 int Number   int64  *int64 long Number   uint32  *uint32 int Number   uint64  *uint64 long Number   sint32  *int32 int Number   sint64  *int64 long Number   fixed32  *uint32 int Number   fixed64  *uint64 long Number   sfixed32  *int32 int Number   sfixed64  *int64 long Number    "});index.add({'id':11,'href':'/docs/sourceoftruth/','title':"Source of Truth",'section':"Docs",'content':"Source of Truth #  The different specification formats can be used as a source or a sink or both of them, but never use sources as source of the specs.\n mermaid.initialize({ \"flowchart\": { \"useMaxWidth\":true }, \"theme\": \"default\" } ) graph LR µSpec -- Spec Spec -- Proto Proto -- µSpec Spec -- µSpec Some transitions will loose information\n Spec --\u0026gt; *  some transitions are destructive\n Proto -\u0026gt; µSpec Spec -\u0026gt; Proto  and some are updating the sinks\n µSpec -\u0026gt; Spec Spec -\u0026gt; µSpec  You should choose one source of truth and stick to it when possible. It is always possible to change.\nSources AND Sink #   Spec µSpec Proto  Sinks only #   Es6Module (by design) Docs U33E Gateway OpenApi  Spec as source #  graph TD Spec -- Proto Spec -- µSpec Spec -- Es6Module Spec -- Docs Spec -- U33E Spec -- ... Proto -- Gateway Proto -- OpenApi Pros  only one kind of spec to work with run your flow at any time with same results (idempotency) guaranteed interoperability from backend to client   Cons  design phase is harder µSpec only for discussions and not for \u0026ldquo;design\u0026rdquo;    Recommended when you only have to maintain an existing project.  µSpec as source #  graph TD Spec -- Proto µSpec --Spec Spec -- Es6Module Spec -- Docs Spec -- U33E Spec -- ... Proto -- Gateway Proto -- OpenApi Pros  fastest variant to design new stuff simplest notation covers \u0026gt;90% of the cases idempotent guaranteed interoperability from backend to client   Cons  working in specs for some edge cases required    Recommended when you have a fresh project or a lot of changes.\nEasiest method when you know protobuf/grpc.\n Proto as source #  graph TD Proto -- µSpec µSpec --Spec Spec -- Es6Module Spec -- Docs Spec -- U33E Spec -- ... Proto -- Gateway Proto -- OpenApi Pros  good solution when everything is already defined in proto covers \u0026gt;80% of the cases idempotent   Cons  destructive step Proto \u0026ndash;\u0026gt; µSpec working in specs for some cases required writing REST service definitions by \u0026ldquo;hand\u0026rdquo; interoperability from backend to client is not guaranteed because some steps are not under control of spectools anymore.    Recommended when you have a huge portfolio of protos and want to bring them to the web (without any changes).  Advanced Setup #  This is a extended µSpec as source variant.\ngraph TD SomeProto -- µSpec µSpec -- Spec Spec -- Proto Spec -- Es6Module Spec -- Docs Spec -- U33E Spec -- ... Proto -- Gateway Proto -- OpenApi Pros  implement external changes very fast designing new stuff still fast guaranteed interoperability from backend to client   Cons  hard setup for the SomeProto part bigger skill set needed partially destructive step    Recommended when you have to import protos to your system. Use \u0026ldquo;µSpec as source\u0026rdquo; first and switch to this variant when you have to.  Multiple Sources of Truth #  The you know what you do mode.\nWhen you have to migrate a project from different spec formats, you have to use this setup. This is not recomended and should still be an exception and not the default.  graph TD SomeProto -- µSpec OtherFormats -- Spec µSpec -- Spec Spec -- Proto Spec -- µSpec Spec -- Es6Module Spec -- Docs Spec -- U33E Spec -- ... Proto -- Gateway Proto -- OpenApi Proto -- µSpec Pros  Do what ever you ever want.   Cons  Dangerous More then one flow required Not idempotent very hard setup    NOT Recommended!\nDo this only when you have to do, try to switch to another setup as fast as you can.\n "});index.add({'id':12,'href':'/docs/overview/using_other_types/','title':"Using Other Types",'section':"Overview",'content':"Using Other Types #  You can use other types as field types. You can use every type from your specs and installed dependencies. You do not need to import them. The imports are resolved and checked by the spectools when you translate your µSecs to standard specs with the command spectools muSpec2spec or with the command muspec checkImpors.\nBy using types which are not installed in the dependencies or not from your spec project, do not forget to import them in your protoc command with \u0026ldquo;-I\u0026rdquo;.\nWhen you need this types on the client side you also need to import them separately.\n For example, let\u0026rsquo;s say you wanted to include sample.Details in sample.Sample on the field details – to do this, you can define another type in the same type µSpec. In standard spec you have to use 2 files, because the standard spec can only handle 1 type per file due to historical reasons:\nFile: muspec/sample.types.yaml\n- type:\u0026#39;sample.Sample #A sample type\u0026#39;fields:password:\u0026#39;* string:1 #The password.\u0026#39;username:\u0026#39;* string:2 #The username or email, or something to identify.\u0026#39;details:\u0026#39;sample.Details:3 #Details.\u0026#39;- type:\u0026#39;sample.Details #A sample type\u0026#39;fields:birth_date:\u0026#39;* google.type.Date:1 #The birth date.\u0026#39;weight:\u0026#39;* number:2 #The weight.\u0026#39;age:\u0026#39;- number:3 #Calculated field for displaying the age, because the calculations are very hard.\u0026#39;"});index.add({'id':13,'href':'/docs/overview/enums/','title':"Enumerations",'section':"Overview",'content':"Enumerations #  Enums are not covered in spectools at the moment.\nCheck this issue for details/dates/state.\n "});index.add({'id':14,'href':'/docs/overview/oneof/','title':"Oneof",'section':"Overview",'content':"Oneof #  If you have a message with many optional fields and where at most one field will be set at the same time.\nIn the client lib, at most one field can be set at the same time. Setting any member of the oneof automatically clears all the other members.\nThe oneof feature is not available µSpec. You have to specify them in the spec.  Using Oneof #  Just define a name for the oneof.\nfields:method:type:stringdescription:The name of the method to call with the wire data. If you want add custom code use source instead of method. /oneof:handler/__proto:number:3oneof:handler__ui:nullmeta:default:\u0026#34;\u0026#34;hint:\u0026#34;\u0026#34;label:furo.u33e.WireHook.method.labeloptions:flags:[]list:[]readonly:falserepeated:falsetypespecific:nullconstraints:{}source:type:stringdescription:Anonyous method to handle the wire. Prefer the use of method. /oneof:handler/__proto:number:4oneof:handler__ui:nullmeta:default:\u0026#34;\u0026#34;hint:\u0026#34;\u0026#34;label:furo.u33e.WireHook.source.labeloptions:flags:[]list:[]readonly:falserepeated:falsetypespecific:nullconstraints:{}The resulting proto would be like:\n// Wire hooks to connect internal wires with methods. message WireHook {  // Short description what you will do when this wire was triggered  string description = 1; // The wire to hook on.  string wire = 2; // Registers the hook as first receiver of the wire.  bool hookBefore = 5; oneof handler { // The name of the method to call with the wire data. If you want add custom code use source instead of method. /oneof:handler/  string method = 3; // Anonyous method to handle the wire. Prefer the use of method. /oneof:handler/  string source = 4; }}"});index.add({'id':15,'href':'/docs/overview/maps/','title':"Maps",'section':"Overview",'content':"Maps #  If you want to create an associative map as part of your data definition, you can define them as a field type like any other type.\nThe key of the map can only be a string.  in µSpec #  fields:properties:\u0026#39;map\u0026lt;string,furo.u33e.Property\u0026gt;:9 #Add properties you want to expose of reflect on your component.\u0026#39;in spec #  fields:properties:type:map\u0026lt;string,furo.u33e.Property\u0026gt;description:Add properties you want to expose of reflect on your component.__proto:number:9oneof:\u0026#34;\u0026#34;__ui:nullmeta:default:\u0026#34;\u0026#34;hint:\u0026#34;\u0026#34;label:furo.u33e.U33eModel.properties.labeloptions:flags:[]list:[]readonly:falserepeated:falsetypespecific:nullconstraints:{}"});index.add({'id':16,'href':'/docs/overview/packages/','title':"Packages",'section':"Overview",'content':"Packages #  Packages are not optional in FIDLs. Even when you are in the same µType file, you have to write at least the deepest package name to address another type from the same package.\nPackages in µType are defined in the type field. The package for the type below will be auth.\n- type:\u0026#39;auth.Credentials #Credentials type for login.\u0026#39;fields:password:\u0026#39;* string:1 #The password.\u0026#39;username:\u0026#39;* string:2 #The username or email, or something to identify.\u0026#39;Packages in µServices will be defined on the package field.\n- name:Authsessiondescription:Login with credentials. The service should set a auth cookie on login and delete it on logoutpackage:authtarget:authservice.protoservices:- md: \u0026#39;Create:POST /auth auth.Credentials , google.protobuf.Empty #Login with credentials #Nimmt die Credentials für die Anmeldung entgegen\u0026#39;- md: \u0026#39;Delete:DELETE /auth google.protobuf.Empty , google.protobuf.Empty #Logout.\u0026#39;Packages in the specs (types and services) are defined in the field __proto.package .\nNote: The fieldname __proto is due to historical reasons, proto was just an extension in the early days of the furo specs.  __proto:package:authtype spec example #  This will result in following spec type, using this config :\nname:Credentialstype:Credentialsdescription:Credentials type for login.__proto:package:authtargetfile:auth.protoimports:[]options:go_package:github.com/veith/doit-specs/dist/pb/auth;authpbjava_multiple_files:\u0026#34;true\u0026#34;java_outer_classname:AuthProtojava_package:com.furo.baseauthfields:password:type:stringdescription:The password.__proto:number:1oneof:\u0026#34;\u0026#34;__ui:nullmeta:default:\u0026#34;\u0026#34;hint:\u0026#34;\u0026#34;label:auth.Credentials.password.labeloptions:flags:[]list:[]readonly:falserepeated:falsetypespecific:nullconstraints:required:is:\u0026#34;true\u0026#34;message:password is requiredusername:type:stringdescription:The username or email, or something to identify.__proto:number:2oneof:\u0026#34;\u0026#34;__ui:nullmeta:default:\u0026#34;\u0026#34;hint:\u0026#34;\u0026#34;label:auth.Credentials.username.labeloptions:flags:[]list:[]readonly:falserepeated:falsetypespecific:nullconstraints:required:is:\u0026#34;true\u0026#34;message:username is required proto example #  The resulting proto will look like this:\n// Code generated by spectools. DO NOT EDIT. syntax = \u0026#34;proto3\u0026#34;;package auth;option go_package = \u0026#34;github.com/veith/doit-specs/dist/pb/auth;authpb\u0026#34;;option java_multiple_files = true;option java_outer_classname = \u0026#34;AuthProto\u0026#34;;option java_package = \u0026#34;com.furo.baseauth\u0026#34;;// Credentials type for login. message Credentials {  // The password.  string password = 1; // The username or email, or something to identify.  string username = 2; }Packages and Name Resolution #   Like in protobuf the type name resolution works like C++: first the innermost scope is searched, then the next-innermost, and so on, with each package considered to be \u0026ldquo;inner\u0026rdquo; to its parent package. A leading \u0026lsquo;.\u0026rsquo; (for example, .foo.bar.Baz) means to start from the outermost scope instead.\nPackages in µSpes #  By translating µSpecs to specs, spectools will refer to the .spectools configuration file for your packages. The java and golang packages are added as corresponding option to the specs. Once setted, the spectools will not change them again.\nspectools:\u0026#34;1.18.1\u0026#34;module:\u0026#34;github.com/veith/doit-specs\u0026#34;version:\u0026#34;v1.0.0\u0026#34;specDir:\u0026#34;./specs\u0026#34;specFormat:\u0026#34;yaml\u0026#34;#set to yaml or jsondependencies:- \u0026#34;git@github.com:theNorstroem/furoBaseSpecs.git v1.11.8\u0026#34;# The importer looks for all **/*.type.spec files recursive The importer looks for all **/*.service.spec files recursivedependenciesDir:dependenciesmuSpec:types:- \u0026#34;./muspecs/**/*types.yaml\u0026#34;- \u0026#34;./muspecs/*types.yaml\u0026#34;services:- \u0026#34;./muspecs/**/*services.yaml\u0026#34;- \u0026#34;./muspecs/*services.yaml\u0026#34;goPackageBase:\u0026#34;github.com/veith/doit-specs/dist/pb/\u0026#34;#this is used to prefix the go package optionjavaPackagePrefix:\u0026#34;com.furo.base\u0026#34;dir:\u0026#34;muspecs\u0026#34;"});index.add({'id':17,'href':'/docs/overview/extensions/extension_proto/','title':"Protobuf Extension",'section':"Extensions",'content':"The Protobuf Extension #  The protobuf extension is meanwhile a fix part of the specs and the spectools.\nIn this, meanwhile built in, extesnion you define things for the protos.\n__proto extension in a type #  The proto extension in a type defines the package, target file, imports (*.proto) and options\n__proto:package:authtargetfile:auth.protoimports:[]options:go_package:github.com/veith/doit-specs/dist/pb/auth;authpbjava_multiple_files:\u0026#34;true\u0026#34;java_outer_classname:AuthProtojava_package:com.furo.baseauth__proto extension in a field of a type #  The proto extension in a field let you define the field id an can set a oneof group.\nfields:id:type:stringdescription:The identifier.__proto:number:1oneof:\u0026#34;\u0026#34;__ui:null__proto extension in a service #  The proto extension in a service defines the package, target file, imports (*.proto) and options\n__proto:package:Services.authtargetfile:auth.protoimports:- google/api/annotations.proto- Services/auth/reqmsgs.proto- google/protobuf/empty.proto- auth/auth.protooptions:go_package:github.com/veith/doit-specs/dist/pb/Services/auth;authpbjava_multiple_files:\u0026#34;true\u0026#34;java_outer_classname:AuthProtojava_package:com.furo.baseServices.auth"});index.add({'id':18,'href':'/docs/overview/extensions/extension_ui/','title':"UI Extension",'section':"Extensions",'content':"__ui extension #  Define some options for the ui-builder (furoc-gen-u33e).\n____ui extension in a field of a type #  fields:id:type:stringdescription:The identifier.__proto:number:1oneof:\u0026#34;\u0026#34;__ui:component:\u0026#34;furo-data-text-input\u0026#34;flags:[]no_init:false"});index.add({'id':19,'href':'/docs/overview/extensions/','title':"Extensions",'section':"Overview",'content':"Extensionpoints #  In the past, extensions were added by adding a field to a spec, using \u0026ldquo;__\u0026rdquo; as prefix. This was no problem, as long the complete build chain was js based, everyone could add his extension to the spec. Adding your custom extensions is still supported, but they have to go to the field extensions. Extensionpoints are available for types, fields in types, services and methods in services. The __proto and __ui extensions were so broadly used, that they become a fix part of the specs.\nExtensions can have any structure and can be used in furoc generator plugins or a scripts that consumes spectools exportAsYaml -f, which is nearly the same structure a furoc generator would receive.\nExtension are only available in the standard spec notation. You can not use them in µSpecs.  Extensions in a service #  name:FruitServiceextensions:dummy:corename:fruitsgen:golangmethods:ListFruits:description:List fruits with pagination.extensions:otherextension:- fastExtensions in a type #  name:Credentialstype:Credentialsdescription:Credentials type for login.__proto:package:authtargetfile:auth.protoimports:[]options:go_package:github.com/veith/doit-specs/dist/pb/auth;authpbjava_multiple_files:\u0026#34;true\u0026#34;java_outer_classname:AuthProtojava_package:com.furo.baseauthfields:password:type:stringdescription:The password.__proto:number:1oneof:\u0026#34;\u0026#34;__ui:nullmeta:default:\u0026#34;\u0026#34;hint:\u0026#34;\u0026#34;label:auth.Credentials.password.labeloptions:flags:[]list:[]readonly:falserepeated:falsetypespecific:nullconstraints:required:is:\u0026#34;true\u0026#34;message:password is requiredextensions:#\u0026lt;-- field extensionsdummyextension:key:a field extensionextensions:#\u0026lt;-- type extensionsdummyextension:key:a type extension"});index.add({'id':20,'href':'/docs/overview/style_guide/','title':"Style Guide",'section':"Overview",'content':"Style Guide #  The style guide is nearly similar to the protocol buffers style guide and follows also the google api design guidelines.\nFile structure #  Files should be named lower_snake_case.types.yaml.\nYou can put the services and types to the same folder (thematic group). You can move the files around without any effect. The resulting protos does not depend on the FIDL file names or structure, they will follow the given package definitions.\nmuspecs ├── auth │ ├── auth.services.yaml │ └── auth.types.yaml └── fruits ├── fruit.services.yaml └── fruits.types.yaml dist/protos ├── Services │ └── auth │ ├── auth.proto │ └── reqmsgs.proto ├── auth │ └── auth.proto └── fruit ├── fruit.proto ├── fruitservice.proto └── reqmsgs.proto Type and field names #  package names #  Use camelCase (without an initial capital) for package names.\nsample.SampleRequest  type names #  Use CamelCase (with an initial capital) for type names.\nsample.SampleRequest  field names #  Use underscore_separated_names for field names for example, birth_date.\nbirth_date  - type:\u0026#39;sample.Sample #A sample type\u0026#39;fields:password:\u0026#39;* string:1 #The password.\u0026#39;birth_date:\u0026#39;* google.type.Date:2 #The username or email, or something to identify.\u0026#39;details:\u0026#39;sample.Details:3 #Details.\u0026#39;If your field name contains a number, the number should appear after the letter instead of after the underscore. e.g., use song_name1 instead of song_name_1\nRepeated fields #  Use pluralized names for repeated fields.\ntags: \u0026lsquo;[] string:1 #Some tags.\u0026rsquo;  Services #  You should use CamelCase (with an initial capital) for both the service name and any method names:\nLook at - name: FruitService , - md: \u0026lsquo;ListFruits: GET /\u0026hellip;. You can find a good guide and explanation on the Standard Methods page of the cloud API design guide page.  - name:FruitServicedescription:| Fruits are healthy, so having a service which can list some fruits would be nice. We do not cover all fruits, but some. The list will grow with time, hopefully. package: fruit target: fruit_service.proto methods: - md: \u0026#39;ListFruits: GET /fruits google.protobuf.Empty , fruit.FruitCollection #Filterable and searchable list of fruits with pagination.\u0026#39; qp: q: \u0026#39;string #Use this to search for a fruit.\u0026#39; filter: \u0026#39;string #Use this field to filter the fruits, this is not searching.\u0026#39; order_by: \u0026#39;string #Use this field to specify the ordering.\u0026#39; page: \u0026#39;string #Use this field to specify page to display.\u0026#39; - md: \u0026#39;Get: GET /fruits/{frt} google.protobuf.Empty , fruit.FruitEntity #Returns a single fruit.\u0026#39; qp: frt: \u0026#39;string #The query param frt stands for the FRuiT id.\u0026#39; URL Path #  Usualy the path part is a noun in plural form. Use singular nouns only on singleton ressources. Do not append a prefix like /api to your paths. Use /fruits.\nTIPP: Assume that your API is a host by its own. So you will address it with api.xy.com/fruits. Having api.xy.com/api/fruits will look strange in that moment.\nAdding prefixes can be done by infrastructure. The furo client libs also have the posibillity to prefix your specs according to the situation.\n You will loose portability capabilities when you prefix your paths.  URL Placeholer / Query Params #  Use short names for the placeholders because they will apear on every request you make and also in the HATEOAS of every response.\nUse some consonants only and use them that you can recognize the word behind, when possible. The first letter of a word is allowed to be a vovel.\nMain objects of your domain should use only two or three letters. A\nq is \u0026ldquo;reserved\u0026rdquo; for search query.  some examples\n fruit =\u0026gt; frt example_data =\u0026gt; exd support_cases spc support_analysis spa  "});index.add({'id':21,'href':'/posts/hello/','title':"Hello",'section':"Blog",'content':"Initial documentation #  Hi and welcome to the first version of the FIDL documentation. If you have some issues, found typos and have suggestions, feel free to open an issue or better make a pull request.\n"});index.add({'id':22,'href':'/docs/specs/services/','title':"Services",'section':"Specs",'content':"Anatomy of a service spec #  A service spec consists of 2 main sections (services and __proto) and some properties on the root node.\nname #  The type of the service without the package name. Follow the style guide and write it in CamelCase with an initial capital.\nversion #  Put any version information of the service. This field does not affect the URL of the services/methods.\nThis property has just informative character at the moment.\ndescription #  Describe the intention of your service in some sentences. You can ommit this field. Spectools will add a default description in the generates “developer was to lazy to give a description”.\nlifecycle #  Lifecycle information for the service. If you set to true, put in a info with an alternative solution and maybe a deadline.\nlifecycle:deprecated:falseinfo:This version is still valid__proto #  The proto section defines some properties to generate the proto files.\n__proto:package:fruittargetfile:fruitservice.protoimports:- google/api/annotations.proto- fruit/reqmsgs.proto- google/protobuf/empty.proto- fruit/fruit.proto- google/protobuf/field_mask.protooptions:go_package:github.com/veith/doit-specs/dist/pb/fruit;fruitpbjava_multiple_files:\u0026#34;true\u0026#34;java_outer_classname:FruitserviceProtojava_package:com.furo.basefruitField package string #  This is the desired proto package name, his field is not optional\nField imports []string #  The imports are checked by the spectools (missing imports will be added). Additional imports will not be removed (maybe you have to do a import for side effects).\nThis can be done with the command spectools checkImports and is done in some other commands too. Imports that can not be found would be reported. So you can check for typos like fruit.FruitCollections which should be a fruit.FruitCollection.\nspecs/Fruitservice.service.spec :Import fruit.FruitCollections not found in Service FruitService on param ListFruitService field options map\u0026lt;string,string\u0026gt; #  When needed, you can add options for your protos. This can be something like the following:\noptions:go_package:github.com/veith/doit-specs/dist/pb/fruit;fruitpbjava_multiple_files:\u0026#34;true\u0026#34;java_outer_classname:FruitserviceProtojava_package:com.furo.basefruitservices map\u0026lt;string, service\u0026gt; #  The most important part of a service spec are the services, what a surprise. The service section contains a map with services. The key is the \u0026ldquo;name\u0026rdquo; of the service and usualy something like List, Get, Delete, Create, Update, CustomName. This names are not the rpc_name.\nA service itself has the properties description, data, deeplink, query and rpc_name.\na single service in detail\nList:description:List fruits with pagination.data:request:google.protobuf.Emptyresponse:fruit.FruitCollectionbodyfield:bodydeeplink:description: \u0026#39;List:GET /fruits google.protobuf.Empty , fruit.FruitCollection #List fruits with pagination.\u0026#39;href:/fruitsmethod:GETrel:listquery:q:description:Use this to search for a fruit.type:stringfilter:description:Use this field to filter the fruits, this is not searching.type:stringorder_by:description:Use this field to specify the ordering.type:stringpage:description:Use this field to specify page to display.type:stringrpc_name:ListFruitsField description string #  It is a good practice to give a good description of the type. This description will go to the generated protos and other generates.\nField data Servicereqres #  Data contains the repuest and response types for the service.\ndata:request:google.protobuf.Emptyresponse:fruit.FruitCollectionbodyfield:bodyrequest string #  Define the request type. Use google.protobuf.Empty if not needed.\nresponse string #  Define the response type. Use google.protobuf.Empty if not needed.\nbodyfield string #  This defines the body field in request the type The name of the request field whose value is mapped to the HTTP request body, or * for mapping all request fields not captured by the path pattern to the HTTP body, or omitted for not having any HTTP request body.\nNOTE: the referred field must be present at the top-level of the request message type.\nField deeplink Servicedeeplink #  General URL Paht information for the service.\ndeeplink for GetFruit\ndeeplink:description: \u0026#39;Get:GET /fruits/{fr} google.protobuf.Empty , fruit.FruitEntity #Returns a single fruit.\u0026#39;href:/fruits/{fr}method:GETrel:selfdescription string #  Writing something like \u0026lsquo;Get: GET /fruits/{fr} google.protobuf.Empty , fruit.FruitEntity #Returns a single fruit.\u0026rsquo; is a good idea. Give additional information for the dev. if needed.\nhref string #  The URL pattern with placeholders, like /fruits/{fr} the service is listening to .\nThe placeholders are defined in the request types.\nmethod string #  The request method/verb the service is listening to.\nThis should be one of the following verbs:\n GET PUT PATCH POST DELETE  Side note: If you set the verb to PUT and add a field update_mask of type google.protobuf.FieldMask to the request type update_mask: 'google.protobuf.FieldMask #Needed to patch a record' , an additional binding for the PATCH verb will be created in the proto. Because it is assumable that your service has patch and put capabilities.  rel string #  Give an according relation type for your link. For GET on entities this is usualy a self and on collections a list. For DELETE a rel delete is set. And on custom methods it is mostly the name of the custom method.\nUse lowercase for the rel.\nField query Queryparam #  The query params for this service. This fields are used by the client lib to proove the capabilities of the service. Spectools will update this list for you, when you come from µSpec. In near future this will be removed, because the information is already available in the request type and must not be written twice.\nA query param consist of a descritpion for the documentation and a type.\nquery:q:description:Use this to search for a fruit.type:stringfilter:description:Use this field to filter the fruits, this is not searching.type:stringThe types and their values must be url safe. They will appear in the query string of the request.  Field rpc_name string #  The rpc name which should appear in the proto. In the example below you can see that the rpc_name was set to CreateFruit\nservice FruitService { // Use this to create new fruits.  rpc CreateFruit (CreateFruitRequest) returns (google.protobuf.Empty){\t//Create: POST /fruits fruit.Fruit , google.protobuf.Empty #Use this to create new fruits. \toption (google.api.http) = {\tpost: \u0026#34;/fruits\u0026#34;\tbody: \u0026#34;body\u0026#34;\t}; }}Example of a \u0026ldquo;Complete\u0026rdquo; Service #  name:FruitServiceversion:\u0026#34;\u0026#34;description:| Fruits are healthy, so having a service which can list some fruits would be nice. We do not cover all fruits, but some. The list will grow with time, hopefully.lifecycle:null__proto:package:fruittargetfile:fruitservice.protoimports:- google/api/annotations.proto- fruit/reqmsgs.proto- google/protobuf/empty.proto- fruit/fruit.proto- google/protobuf/field_mask.protooptions:go_package:github.com/veith/doit-specs/dist/pb/fruit;fruitpbjava_multiple_files:\u0026#34;true\u0026#34;java_outer_classname:FruitserviceProtojava_package:com.furo.basefruitservices:List:description:List fruits with pagination.data:request:google.protobuf.Emptyresponse:fruit.FruitCollectionbodyfield:bodydeeplink:description: \u0026#39;List:GET /fruits google.protobuf.Empty , fruit.FruitCollection #List fruits with pagination.\u0026#39;href:/fruitsmethod:GETrel:listquery:q:description:Use this to search for a fruit.type:stringfilter:description:Use this field to filter the fruits, this is not searching.type:stringorder_by:description:Use this field to specify the ordering.type:stringpage:description:Use this field to specify page to display.type:stringrpc_name:ListFruitsGet:description:Returns a single fruit.data:request:google.protobuf.Emptyresponse:fruit.FruitEntitybodyfield:bodydeeplink:description: \u0026#39;Get:GET /fruits/{fr} google.protobuf.Empty , fruit.FruitEntity #Returns a single fruit.\u0026#39;href:/fruits/{fr}method:GETrel:selfquery:fr:description:The query param fr stands for FR id.type:stringrpc_name:GetFruitCreate:description:Use this to create new fruits.data:request:fruit.Fruitresponse:google.protobuf.Emptybodyfield:bodydeeplink:description: \u0026#39;Create:POST /fruits fruit.Fruit , google.protobuf.Empty #Use this to create new fruits.\u0026#39;href:/fruitsmethod:POSTrel:createquery:{}rpc_name:CreateFruitUpdate:description:Use this to update existing fruits.data:request:fruit.Fruitresponse:fruit.FruitEntitybodyfield:bodydeeplink:description: \u0026#39;Update:PUT /fruits/{fr} fruit.Fruit , fruit.FruitEntity #Use this to update existing fruits.\u0026#39;href:/fruits/{fr}method:PUTrel:updatequery:fr:description:fr string.type:stringupdate_mask:description:Needed to patch a recordtype:google.protobuf.FieldMaskrpc_name:UpdateFruitDelete:description:Use this to delete existing fruits.data:request:google.protobuf.Emptyresponse:google.protobuf.Emptybodyfield:bodydeeplink:description: \u0026#39;Delete:DELETE /fruits/{fr} google.protobuf.Empty , google.protobuf.Empty #Use this to delete existing fruits.\u0026#39;href:/fruits/{fr}method:DELETErel:deletequery:fr:description:fr string.type:stringrpc_name:DeleteFruitDeleteAll:description:Use this to delete ALL fruits.data:request:google.protobuf.Emptyresponse:google.protobuf.Emptybodyfield:bodydeeplink:description: \u0026#39;DeleteAll:DELETE /fruits google.protobuf.Empty , google.protobuf.Empty #Use this to delete ALL fruits.\u0026#39;href:/fruitsmethod:DELETErel:deleteallquery:{}rpc_name:DeleteAllFruitsFerment:description:Fermented fruits tastes very good in liquid form.data:request:google.protobuf.Emptyresponse:google.protobuf.Emptybodyfield:bodydeeplink:description: \u0026#39;Ferment:POST /fruits/{fr}:ferment google.protobuf.Empty , google.protobuf.Empty #Custom methods are always POST.\u0026#39;href:/fruits/{fr}:fermentmethod:POSTrel:fermentquery:fr:description:fr is the placeholder for the fruit id.type:stringrpc_name:FermentFruit"});index.add({'id':23,'href':'/docs/%C2%B5Specs/services/','title':"Services",'section':"µSpecs",'content':"Anatomy of a service µSpec #  The µService specs are regular yaml files.\nThe “service-object” contains 5 fields. The fields name, package and methods are mandatory, the field target and description is optional and autogenerated when ommited.\nYou can have as many service definitions per file as you want. It makes sense that you put types in a file, that belongs togehter.\nThe field methods in µServcies will translate to services in the standard notation for compatibility reasons, because the standard notation is some years old and changing this would be a breaking change we do not want to do at the moment.  - name:FruitServicedescription:Fruits are healthy, so having a service which can list some fruits would be nice.package:fruittarget:fruit_service.protomethods:- md: \u0026#39;ListFruits:GET /fruits google.protobuf.Empty , fruit.FruitCollection #Filterable and searchable list of fruits with pagination.\u0026#39;qp:q:\u0026#39;string #Use this to search for a fruit.\u0026#39;filter:\u0026#39;string #Use this field to filter the fruits, this is not searching.\u0026#39;order_by:\u0026#39;string #Use this field to specify the ordering.\u0026#39;page:\u0026#39;string #Use this field to specify page to display.\u0026#39;The Name #  The name of the Service. Visit the style guide for good naming. Can not contain spaces.\nThe Description #  Describe the intention of your service in some sentences. You can ommit this field. Spectools will add a default description \u0026ldquo;developer was to lazy to give a description\u0026rdquo;.\nThe Package #  Define the package, this service belongs too.\nThe Target #  The target proto file for the generated proto. Spectools can not generate proto files which mixes types and services.\nThe Method definition #  The method defiton is made like the type line in µTypes\nmethods:- md: \u0026#39;GetFruit:GET /fruits/{frt} google.protobuf.Empty , fruit.FruitCollection #Filterable list of fruits.\u0026#39;!_! !______!^ !__! !_____!!__!!____________________! ^!____________________! !_________________________!| | | | | | | | | |the field | (:) | | | the request type | | || | | placeholder | the response type || | the URL | descriptionmethod name | a commathe http verb The Method Name #  The method name should follow the naming conventions from the google api design guide. Default names are (with fruit as example)\n ListFruits with a verb GET to receive a list of fruits GetFruit with a verb GET and an identifier placeholder to get a single record UpdateFruit with a verb PUT or PATCH and an identifier placeholder to update a single record CreateFruit with a verb POST to create a single record DeleteFruit with a verb DELETE and an identifier placeholder to delete a single record DeleteAllFruits with a verb DELETE to delete all records on this path CustomMethod with a verb POST to do custom stuff that does not fit in the other methods. Uses always a POST.  The HTTP Verb #  Use the standard Http verbs (GET, PUT, PATCH, POST, DELETE) according to the idempotency, except on custom methods, they should always use POST.\nThe URL with Placeholder #  Usualy the path part is a noun in plural form. Use singular nouns only on singleton ressources. Do not append a prefix like /api to your paths. Use /fruits.\nTIPP: Assume that your API is a host by its own. So you will address it with api.xy.com/fruits. Having api.xy.com/api/fruits will look strange in that moment.\nAdding prefixes can be done by infrastructure. The furo client libs also have the posibillity to prefix your specs according to the situation.\n You will loose portability capabilities when you prefix your paths.  The Request Type #  On GET requests you can not send a body, therfore you will put a google.protobuf.Empty type here. On DELETE requests you can not send a body, therfore you will put a google.protobuf.Empty type here. On the other verbs, set the type to one of the types in your project specs or installed specs.\nThe Response Type #  Usualy you should use a entity or collection type as response (this is what the client libs loves to work with). But you are free to define any response type as long all participants on client and server side know it. You will get the entity and collection types nearly for free, by adding (ce) in the type line of the µType specs.\nDescription #  Again, descriptions are always optional, but strongly recomended to fill in. They will apear in every generate and can give good hints to the devs who have to implement the specs.\nThe Query Params #  Methods can have query params as part of the URL path (placeholders) and as query part.\nTIPP: be lazy and just write your /paths/with/{phdr}/fruits/{frt}.\nThen run spectool muSrvSanitize.\nThis will add the missing query params to your spec with a default description.\n qp:q:\u0026#39;string #Use this to search for a fruit.\u0026#39;^ !_____! !______________________________!| | || type description | the name of the query param The Query Param Name #  The name must match with the used placeholders for the path part. Query params should fullfill the RFC3986. Otherwise you risk to never receive the param on the server side.\nThe Query Param Type #  The type is mostly a string. You can use any type which is url safe.\nThe Query Param Description #  Ceterum censeo, descriptions are useful information.\nCustom Methods in Detail #  todo: write something about that.\n"});})();